import shlex
from pyroute2 import IPRoute
from logging import getLogger
from subprocess import check_call, CalledProcessError, Popen
from os.path import join
from psutil import process_iter

from vnet_manager.conf import settings
from vnet_manager.utils.mac import random_mac_generator

logger = getLogger(__name__)


def check_if_interface_exists(ifname):
    """
    Check if an interface exists
    :param str ifname: The interface name to check for
    :return: bool: True if the interface exists, False otherwise
    """
    iface = IPRoute().link_lookup(ifname=ifname)
    return True if iface else False


def create_vnet_interface(ifname):
    """
    Creates a VNet bridge interface
    :param str ifname: The name of the interface to create
    """
    logger.info("Creating VNet bridge interface {}".format(ifname))
    ip = IPRoute()
    ip.link("add", ifname=ifname, kind="bridge")
    # Block traffic to the outside world
    create_vnet_interface_iptables_rules(ifname)
    # Bring up the interface
    configure_vnet_interface(ifname)


def create_vnet_interface_iptables_rules(ifname):
    """
    VNet interfaces should act as dump bridges and should not have any connectivity to the outside world
    So this function makes some IPtables rules to make sure the VNet interface cannot talk to the outside.
    :param str ifname: The interface the create IPtables rules for
    """
    rule = "OUTPUT -o {} -j DROP".format(ifname)
    # First we check if the rule already exists
    try:
        check_call(shlex.split("iptables -C {}".format(rule)))
        logger.debug("IPtables DROP rule for VNet interface {} already exists, skipping creation".format(ifname))
    except CalledProcessError:
        logger.info("Creating IPtables DROP rule to the outside world for VNet interface {}".format(ifname))
        try:
            check_call(shlex.split("iptables -A {}".format(rule)))
        except CalledProcessError as e:
            logger.error("Unable to create IPtables rule, got output: {}".format(e.output))


def configure_vnet_interface(ifname):
    """
    Configures an vnet interface to be in the correct state for forwarding vnet machine traffic
    :param str ifname: The vnet interface to configure
    """
    ip = IPRoute()
    dev = ip.link_lookup(ifname=ifname)[0]
    # Make sure it's set to down state
    ip.link("set", index=dev, state="down")
    # Set the mac
    ip.link("set", index=dev, address=random_mac_generator())
    # Bring up the interface
    ip.link("set", index=dev, state="up")


def check_vnet_interface_status(config, sniffer=False):
    """
    Check the status of the vnet interfaces defined in the config
    This function will correct the status if it is wrong
    :param dict config: The config generated by get_config()
    :param bool sniffer: Check for a sniffer process and create it if it does not exist
    """
    for bridge in range(0, config["switches"]):
        ifname = settings.VNET_BRIDGE_NAME + str(bridge)
        if not check_if_interface_exists(ifname):
            create_vnet_interface(ifname)
        # Make sure the interface is up
        IPRoute().link("set", ifname=ifname, state="up")
        if sniffer and not check_if_sniffer_exists(ifname):
            # Create it
            # TODO
            pass


def check_if_sniffer_exists(ifname):
    """
    Check if there is already a sniffer running for a VNet interface
    :param str ifname: The VNet interface name to check
    :return bool: True if it exists, False otherwise
    """
    for process in process_iter():
        if "tcpdump" in process.cmdline() and ifname in process.cmdline():
            return True
    return False


def start_tcpdump_on_vnet_interface(ifname):
    """
    Starts a tcpdump process on a vnet interface
    :param str ifname: The interface to start the tcpdump on
    """
    path = join(settings.VNET_SNIFFER_PCAP_DIR, "{}.pcap".format(ifname))
    logger.info("Starting sniffer on VNet interface {}, PCAP location: {}".format(ifname, path))
    Popen(shlex.split("tcpdump -i {} -U -w {}".format(ifname, path)))
