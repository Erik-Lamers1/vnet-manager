from ipaddress import IPv4Interface, IPv6Interface
from re import fullmatch
from logging import getLogger
from os.path import isdir, isfile, join
from copy import deepcopy

from vnet_manager.utils.mac import random_mac_generator
from vnet_manager.conf import settings

logger = getLogger(__name__)


class ValidateConfig:
    """
    Validates the config generated by get_config() and updates some values if missing
    """

    def __init__(self, config):
        """
        :param dict config: The config generated by get_config()
        """
        self._all_ok = True
        self._validators_ran = 0
        self._new_config = deepcopy(config)
        self.default_message = ". Please check your settings"
        self.config = config

    def __str__(self):
        return "VNet config validator, current_state: {}, amount of validators run: {}".format(
            "OK" if self._all_ok else "NOT OK", self._validators_ran
        )

    @property
    def config_validation_successful(self):
        """
        This property can be called to see if any unrecoverable errors in the config have been found
        """
        return self._all_ok

    @property
    def updated_config(self):
        """
        This property contains a updated config dict, with all values that have been fixed by this validator
        """
        return self._new_config

    @property
    def validators_ran(self):
        """
        Return the amount of validators that have been run
        """
        return self._validators_ran

    def validate(self):
        """
        Run all validation functions
        """
        self._all_ok = True
        self.validate_provider_config()
        self.validate_switch_config()
        self.validate_machine_config()

    def validate_provider_config(self):
        """
        Validates the provider part of the config
        """
        self._validators_ran += 1
        if "providers" not in self.config:
            logger.error("Providers dict not found in config, this usually means the default config is not correct" + self.default_message)
            self._all_ok = False
        elif not isinstance(self.config["providers"], dict):
            logger.error("Providers is not a dict, this means the default config is corrupt" + self.default_message)
            self._all_ok = False
        else:
            for name, values in self.config["providers"].items():
                if "supported_operating_systems" not in values:
                    logger.error("No supported operating systems found for provider {}".format(name) + self.default_message)
                    self._all_ok = False
                elif not isinstance(values["supported_operating_systems"], list):
                    logger.error("supported_operating_systems for provider {} is not a list".format(name) + self.default_message)
                    self._all_ok = False
                if "dns-nameserver" not in values or not isinstance(values["dns-nameserver"], str):
                    logger.warning("DNS nameserver not correctly set for provider {}. Defaulting to 8.8.8.8".format(name))
                    self._new_config["providers"][name]["dns-nameserver"] = "8.8.8.8"
                if "required_host_packages" not in values or not isinstance(values["required_host_packages"], list):
                    logger.warning("Required host packages not correctly set for provider {}. Defaulting to empty list".format(name))
                    self._new_config["providers"][name]["required_host_packages"] = list()
                if "guest_packages" not in values or not isinstance(values["guest_packages"], list):
                    logger.warning("Guest packages not correctly set for provider {}. Defaulting to empty list".format(name))
                    self._new_config["providers"][name]["guest_packages"] = list()
                if "base_image" not in values:
                    logger.error("No base_image found for provider {}".format(name) + self.default_message)
                    self._all_ok = False
                elif not isinstance(values["base_image"], dict):
                    logger.error("base_image for provider {} is not a string.".format(name) + self.default_message)
                    self._all_ok = False
                # Validate the base image
                self.validate_base_image_parameters(name)

    def validate_base_image_parameters(self, provider):
        """
        Validates the provider base image parameters for a particiar provider
        Assumes the base_image dict exists for that provider
        :param str provider: The provider base image parameters to verify
        """
        base_image_config = self.config["providers"][provider]["base_image"]
        if "os" not in base_image_config:
            logger.error("Provider {} is missing OS in the base image config".format(provider))
            self._all_ok = False
        elif not isinstance(base_image_config["os"], str):
            logger.error("Provider {} OS for base image config is not a string".format(provider))
            self._all_ok = False
        if "server" not in base_image_config:
            logger.error("Provider {} is missing server in the base image config".format(provider))
            self._all_ok = False
        elif not isinstance(base_image_config["server"], str):
            logger.error("Provider {} server for base image config is not a string".format(provider))
            self._all_ok = False
        if "protocol" not in base_image_config:
            logger.error("Provider {} is missing protocol in the base image config".format(provider))
            self._all_ok = False
        elif not isinstance(base_image_config["protocol"], str):
            logger.error("Provider {} protocol for base image config is not a string".format(provider))
            self._all_ok = False

    def validate_switch_config(self):
        """
        Validates the switch part of the config
        """
        self._validators_ran += 1
        if "switches" not in self.config:
            logger.error("Config item 'switches' missing" + self.default_message)
            self._all_ok = False
        elif not isinstance(self.config["switches"], int):
            logger.error("Config item 'switches: {}' does not seem to be an integer".format(self.config["switches"]) + self.default_message)
            self._all_ok = False

    def validate_machine_config(self):
        """
        Validates the machines part of the config
        """
        self._validators_ran += 1
        if "machines" not in self.config:
            logger.error("Config item 'machines' missing" + self.default_message)
            self._all_ok = False
        elif not isinstance(self.config["machines"], dict):
            logger.error("Machines config is not a dict, this means the user config is incorrect" + self.default_message)
            self._all_ok = False
        else:
            for name, values in self.config["machines"].items():
                if "type" not in values:
                    logger.error("Type not found for machine {}".format(name) + self.default_message)
                    self._all_ok = False
                elif values["type"] not in settings.SUPPORTED_MACHINE_TYPES:
                    logger.error(
                        "Type {} for machine {} unsupported. I only support the following types: {}".format(
                            values["type"], name, settings.SUPPORTED_MACHINE_TYPES
                        )
                        + self.default_message
                    )
                    self._all_ok = False

                # Files
                if "files" in values:
                    if not isinstance(values["files"], dict):
                        logger.error("Files directive for machine {} is not a dict".format(name) + self.default_message)
                        self._all_ok = False
                    else:
                        # Check the files
                        self.validate_machine_files_parameters(name)

                # Interfaces
                if "interfaces" not in values:
                    logger.error("Machine {} does not appear to have any interfaces".format(name) + self.default_message)
                    self._all_ok = False
                elif not isinstance(values["interfaces"], dict):
                    logger.error(
                        "The interfaces for machine {} are not given as a dict, this usually means a typo in the config".format(name)
                        + self.default_message
                    )
                    self._all_ok = False
                else:
                    self.validate_interface_config(name)

    def validate_machine_files_parameters(self, machine):
        """
        Validates the files config of a particular machine
        Assumes the files dict exists for that machine
        :param str machine: The machine to validates the files config for
        """
        files = self.config["machines"][machine]["files"]
        for host_file in files.keys():
            # First check if the user gave a relative dir from the config dir
            if isdir(join(self.config["config_dir"], host_file)) or isfile(join(self.config["config_dir"], host_file)):
                logger.debug(
                    "Updating relative host_file path {} to full path {}".format(host_file, join(self.config["config_dir"], host_file))
                )
                self._new_config["machines"][machine]["files"][join(self.config["config_dir"], host_file)] = self._new_config["machines"][
                    machine
                ]["files"].pop(host_file)
            # Check for absolute paths
            elif not isdir(host_file) or not isfile(host_file):
                logger.error(
                    "Host file {} for machine {} does not seem to be a dir or a file".format(host_file, machine) + self.default_message
                )
                self._all_ok = False

    def validate_interface_config(self, machine):
        """
        Validates the interface config of a particular machine
        Assumes the interfaces dict exists for that machine
        :param str machine: the machine to validate the interfaces config for
        """
        interfaces = self.config["machines"][machine]["interfaces"]
        for int_name, int_vals in interfaces.items():
            if "ipv4" not in int_vals:
                logger.error("ipv4 not found for interface {} on machine {}".format(int_name, machine) + self.default_message)
                self._all_ok = False
            else:
                # Validate the given IP
                try:
                    IPv4Interface(int_vals["ipv4"])
                except ValueError as e:
                    logger.error("Unable to parse IPv4 address {} for machine {}. Parse error: {}".format(int_vals["ipv4"], machine, e))
                    self._all_ok = False
            if "ipv6" not in int_vals:
                logger.info(
                    "No IPv6 found for interface {} on machine {}, that's okay no IPv6 address will be configured".format(int_name, machine)
                )
            else:
                # Validate the given IP
                try:
                    IPv6Interface(int_vals["ipv6"])
                except ValueError as e:
                    logger.error("Unable to parse IPv6 address {} for machine {}. Parse error: {}".format(int_vals["ipv6"], machine, e))
                    self._all_ok = False
            if "mac" not in int_vals:
                logger.info("MAC not found for interface {} on machine {}, generating a random one".format(int_name, machine))
                self._new_config["machines"][machine]["interfaces"][int_name]["mac"] = random_mac_generator()
            # From: https://stackoverflow.com/a/7629690/8632038
            elif not fullmatch(r"^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$", int_vals["mac"]):
                logger.error(
                    "MAC {} for interface {} on machine {}, does not seem to be valid".format(int_vals["mac"], int_name, machine)
                    + self.default_message
                )
                self._all_ok = False
            if "bridge" not in int_vals:
                logger.error("bridge keyword missing on interface {} for machine {}".format(int_name, machine) + self.default_message)
                self._all_ok = False
            elif not isinstance(int_vals["bridge"], int) or int_vals["bridge"] > self.config["switches"] - 1:
                logger.error(
                    "Invalid bridge number detected for interface {} on machine {}. "
                    "The bridge keyword should correspond to the interface number of the vnet bridge to connect to "
                    "(starting at iface number 0)".format(int_name, machine)
                )
                self._all_ok = False
